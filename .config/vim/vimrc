" vimrc
"
" Requires Vim9+ and `ripgrep`.

" Set XDG-compliant directories.
let vim_home = $XDG_CONFIG_HOME . '/vim'
let vim_state = $XDG_STATE_HOME . '/vim'
let fzf_data = $XDG_DATA_HOME . '/fzf'

" Configure state files and directories.
call mkdir(vim_state, 'p')
let &viminfofile = vim_state . '/viminfo'
let &backupdir = vim_state . '//'
let &directory = vim_state . '//'
let &viewdir = vim_state . '//'
let &undodir = vim_state . '//'

" Remove if using Vim9.1.0327 or newer.
set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

" Install the `vim-plug` plugin manager. Commands:
" - :PlugInstall
" - :PlugUpdate
" - :PlugClean
if empty(glob(vim_home . '/autoload/plug.vim'))
  silent execute '!curl -fLo "' . vim_home . '/autoload/plug.vim" --create-dirs'
      \ . ' https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" Enable plugins via vim-plug.
call plug#begin(vim_home . '/plugged')
Plug 'editorconfig/editorconfig-vim'  " File encodings, indentation, etc.
Plug 'tpope/vim-sensible'  " Sensible settings.
Plug 'tpope/vim-surround'  " Better surround motions.
Plug 'tpope/vim-commentary'  " Commenting lines.
Plug 'mhinz/vim-signify'  " VCS gutter signs for changed lines.
Plug 'airblade/vim-rooter'  " Auto-cd to project root if any.
Plug 'mkitt/tabline.vim'  " Tab numbers in tab line.
Plug 'easymotion/vim-easymotion'  " Better navigation motions.
Plug 'udalov/kotlin-vim'  " Kotlin syntax highlighting.
Plug 'sainnhe/sonokai'  " Sonokai colorscheme.
" Better `tmux` integration.
Plug 'christoomey/vim-tmux-navigator'
Plug 'RyanMillerC/better-vim-tmux-resizer'
" Fuzzy searching.
Plug 'junegunn/fzf.vim'
Plug 'junegunn/fzf', { 'dir': fzf_data, 'do': './install --xdg --all' }
" Vim LSP plugins.
Plug 'prabirshrestha/vim-lsp'
Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/asyncomplete-lsp.vim'
Plug 'mattn/vim-lsp-settings'
" Code formatting.
Plug 'google/vim-maktaba'
Plug 'google/vim-glaive'
Plug 'google/vim-codefmt'
call plug#end()
call glaive#Install()

" Use the system clipboard.
set clipboard=unnamedplus

" Always assume Unix-style files.
set fileformats=unix

" When wrap is set to off lines will not wrap.
set nowrap

" Show cursor line only in focused pane.
augroup CursorLine
  au!
  au VimEnter * setlocal cursorline
  au WinEnter * setlocal cursorline
  au BufEnter * setlocal cursorline
  au WinLeave * setlocal nocursorline
augroup END

" Print relative line numbers in front of each line.
set relativenumber

" Print the absolute line number in front of the current line.
set number

" Highlight tabs, trailing whitespaces, and overrunning lines.
set list

" When a bracket is inserted, briefly jump to the matching one.
set showmatch

" Show current mode.
set showmode

" Show command in the last line of the screen.
set showcmd

" Set custom status line.
set statusline=[%f]%([%M%R%H%W]%)%q%=[\ %l:%c\ \|\ %p%%\ \|\ %LL\ ]

" When there is a previous search pattern, highlight all its matches.
set hlsearch

" Ignore case in search patterns.
set ignorecase

" When increasing / decreasing indent level, round to nearest multiple of
" shiftwidth.
set shiftround

" Copy indent from current line when starting a new line.
set autoindent

" Do smart autoindenting when starting a new line.
set smartindent

" Open new split panes to right and bottom, which feels more natural.
set splitbelow
set splitright

" Don't use characters for vertical split delimiter.
set fillchars+=vert:\ ,

" Enable sign column.
set signcolumn=yes

" When set to "dark", Vim wil try to use colors that look good on a dark
" background.
set background=dark

" Make Esc more responsive.
set timeout ttimeoutlen=10

" Copy until the end of the line. Consistent with D and C.
nnoremap Y y$

" Exit visual mode with q.
vnoremap q <esc>

" Cancels search highlighting in normal mode.
nnoremap <esc> :nohlsearch<CR>

" Set <leader> and macro autocompletion keys. Must not have surrounding spaces.
noremap <space> <nop>
let mapleader=" "
set wildcharm=<C-z>

" Writes all buffers before navigating outside of Vim.
let g:tmux_navigator_save_on_switch=1

" If Vim is the zoomed pane, wraps around Vim instead of unzooming.
let g:tmux_navigator_disable_when_zoomed=1

" Panes should be resized in increments of 5.
let g:tmux_resizer_resize_count=5
let g:tmux_resizer_vertical_resize_count=5

" Required to map the Alt key.
for key in "hjkl="
  execute "set <M-" . key . ">=\e" . key
endfor

" Control and navigate panes:
" - Ctrl-o (new file in current buffer)
" - Ctrl-t (new tab)
" - Ctrl-s/v (split pane horizontally / vertically)
" - Ctrl-h/j/k/l (navigate panes)
" - Alt-h/j/k/l (resize panes)
" - Alt-= (resize all panes equally)
" - Ctrl-z (close all panes except current one)
" - Ctrl-x (close pane)
" - Ctrl-w (close tab)
nnoremap <C-o> :edit %:p:h<C-z>
nnoremap <C-t> :tabedit %<CR>
nnoremap <C-s> :split<CR>
nnoremap <C-v> :vsplit<CR>
nnoremap <M-=> <C-w>=
nnoremap <C-z> :only<CR>
nnoremap <C-x> :quit<CR>
nnoremap <C-w> :tabclose<CR>

" Navigation actions:
" - g1 /g2 / ... / g9 (go to tab)
" - gj / gk (go to previous / next location)
" - gf (go to file under cursor or to selected file)
" - go (open URI under cursor or selected URI)
" - [c / ]c / [C / ]C (go to previous / next / first / last changed hunk)
" - [m / ]m (go to previous / next start of Java-style method or class)
" - [M / ]M (go to previous / next end of Java-style method or class)
" - { / } (go to previous / next blank line)
" - Ctrl-u/d (go half page up / down)
nnoremap g1 1gt
nnoremap g2 2gt
nnoremap g3 3gt
nnoremap g4 4gt
nnoremap g5 5gt
nnoremap g6 6gt
nnoremap g7 7gt
nnoremap g8 8gt
nnoremap g9 9gt
nnoremap gj <C-o>
nnoremap gk <C-i>
map go gx

" Code commenting:
" - <leader>c (comment line or selected range)
noremap <leader>c :Commentary<CR>

" Autocomplete shortcuts:
" - Ctrl-Space (trigger autocomplete)
" - Ctrl-n/p (cycle options)
" - Ctrl-y (accept option)
" - Ctrl-e (cancel)
imap <C-@> <C-space>
imap <C-space> <C-x><C-o>

" Enable default autocompletion.
set omnifunc=syntaxcomplete#Complete

function! s:try_set_colorscheme()
  " Optionally enable a color scheme if the terminal supports colors. The color
  " scheme must be set after setting the background and enabling syntax.
  if &t_Co >= 256
    try
      colorscheme $COLORSCHEME
    catch
      echo "Colorscheme " . $COLORSCHEME . " not found!"
    endtry
  endif
endfunction

augroup ColorScheme
  au!
  autocmd VimEnter * call s:try_set_colorscheme()
augroup END

" Fuzzy searching:
" - ss (search everywhere in project)
" - sf (search files)
" - sc (search uncommitted Git files)
" - sb (search open buffers)
" - s/ (search inside current buffer)
" - sh (search home directory)
" - Ctrl-n/p (cycle options)
" - Ctrl-o (open option in current buffer)
" - Ctrl-t (open option in new tab)
" - Ctrl-s/v (open option in horizontal / vertical split)
" - Ctrl-e (cancel)
nnoremap s <nop>
nnoremap ss :Rg<CR>
nnoremap sf :Files<CR>
nnoremap sc :GFiles?<CR>
nnoremap sb :Buffers<CR>
nnoremap s/ :BLines<CR>
nnoremap sh :FZF ~<CR>
let g:fzf_action = {
    \ 'ctrl-t': 'tab split',
    \ 'ctrl-s': 'split',
    \ 'ctrl-v': 'vsplit' }

" Code navigation:
" - gd (go to definition)
" - gD (go to declaration)
" - gi (go to implementation)
" - [r / ]r (go to previous / next reference)
" - [e / ]e (go to previous / next error)
" - [w / ]w (go to previous / next warning)
" - [d / ]d (go to previous / next diagnostic)
" - <leader><leader> + motion (trigger EasyMotion)
nmap gd <plug>(lsp-definition)
nmap gD <plug>(lsp-declaration)
nmap gi <plug>(lsp-implementation)
nmap [r <plug>(lsp-previous-reference)
nmap ]r <plug>(lsp-next-reference)
nmap [e <plug>(lsp-previous-error)
nmap ]e <plug>(lsp-next-error
nmap [w <plug>(lsp-previous-warning)
nmap ]w <plug>(lsp-next-warning)
nmap [d <plug>(lsp-previous-diagnostic)
nmap ]d <plug>(lsp-next-diagnostic)

" Show diagnostics inline and as float on cursor hover.
let g:lsp_diagnostics_virtual_text_align = 'after'
let g:lsp_diagnostics_virtual_text_padding_left = 2
let g:lsp_diagnostics_virtual_text_wrap = 'truncate'
let g:lsp_diagnostics_float_cursor = 1

" Use Nerd Font icons for diagnostics.
let g:lsp_diagnostics_signs_error = {'text': ''}
let g:lsp_diagnostics_signs_warning = {'text': ''}
let g:lsp_diagnostics_signs_information = {'text': ''}
let g:lsp_document_code_action_signs_hint = {'text': '󰌶'}

" Code inspection and transformation:
" - <leader>h (show help)
" - <leader>f (find references)
" - <leader>t (type hierarchy)
" - <leader>r (rename)
" - <leader>c (comment line or selected range)
" - <leader>= (format file or selected range)
" - <leader>q (toggle quickfix pane)
" - Ctrl-f/b (scroll float forward / backward)
" - Ctrl-c (close float)
nmap <leader>h <plug>(lsp-hover-float)
nmap <leader>f <plug>(lsp-references)
nmap <leader>t <plug>(lsp-type-hierarchy)
nmap <leader>r <plug>(lsp-rename)
nnoremap <leader>= :FormatCode<CR>
vnoremap <leader>= :FormatLines<CR>
nnoremap <expr> <leader>q
    \ empty(filter(getwininfo(), 'v:val.quickfix'))
    \ ? ":copen\<CR>" : ":cclose\<CR>"
nmap <expr> <C-f> lsp#scroll(-5)
nmap <expr> <C-b> lsp#scroll(+5)

" Code actions shortcuts:
" - <leader>a (trigger code actions)
" - # (accept numbered option)
" - Ctrl-n/p (cycle options)
" - Enter (accept selected option)
" - Esc / Ctrl-c (cancel)
nmap <leader>a <plug>(lsp-code-action-float)

function! s:on_lsp_buffer_enabled() abort
  " Enable LSP autocompletion.
  setlocal omnifunc=lsp#complete
  if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif

  " Override autocomplete action.
  imap <buffer> <C-space> <plug>(asyncomplete_force_refresh)
endfunction

augroup lsp_install
  au!
  " Call s:on_lsp_buffer_enabled only for languages that have the server
  " registered.
  autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END

Glaive codefmt shfmt_options=`['-i', '2', '-sr', '-ci', '-bn', '-kp']`
