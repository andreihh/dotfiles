" vimrc: configures Vim.
"
" Requirements:
" - Terminal capabilities: truecolors, Nerd Font, OSC52
" - Tools: `git`, `curl`, `fzf`, `fd`, `ripgrep`

" [[ XDG specification ]]

" Define XDG directories if unset.
if empty($XDG_CONFIG_HOME)
  let $XDG_CONFIG_HOME = $HOME . '/.config'
endif
if empty($XDG_DATA_HOME)
  let $XDG_DATA_HOME = $HOME . '/.local/share'
endif
if empty($XDG_STATE_HOME)
  let $XDG_STATE_HOME = $HOME . '/.local/state'
endif

" Set XDG-compliant directories.
let s:vim_home = $XDG_CONFIG_HOME . '/vim'
let s:vim_data = $XDG_DATA_HOME . '/vim'
let s:vim_state = $XDG_STATE_HOME . '/vim'

" Configure spell directory.
call mkdir(s:vim_home . 'spell', 'p')

" Configure state files and directories.
for dir in ['', 'backup', 'swap', 'view', 'undo', 'session']
  call mkdir(s:vim_state . '/' . dir, 'p')
endfor
let &viminfofile = s:vim_state . '/viminfo'
let &backupdir = s:vim_state . '/backup//'
let &directory = s:vim_state . '/swap//'
let &viewdir = s:vim_state . '/view//'
let &undodir = s:vim_state . '/undo//'
let g:netrw_home = s:vim_state

" Configure plugin files and directories.
let s:plug_script = s:vim_home . '/autoload/plug.vim'
let s:plug_dir = s:vim_data . '/plugged'
let s:plug_url =
    \ 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'

" [[ Plugins ]]

" Enable native plugins.
packadd! editorconfig  " File encodings, indentation, etc.
packadd! comment  " Commenting lines
packadd! matchit  " Better % matching

" Install the `vim-plug` plugin manager. Commands:
" - :PlugInstall
" - :PlugUpdate
" - :PlugClean
if empty(glob(s:plug_script))
  execute '!curl -fLo "' . s:plug_script . '" --create-dirs ' . s:plug_url
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" Enable plugins via `vim-plug`.
call plug#begin(s:plug_dir)
" Core plugins
Plug 'tpope/vim-sensible'  " Sensible settings
Plug 'tpope/vim-surround'  " Better surround motions
Plug 'mhinz/vim-startify'  " Starting dashboard and session management
Plug 'easymotion/vim-easymotion'  " Better navigation motions
Plug 'ojroques/vim-oscyank'  " OSC52 support
" `tmux` integration
Plug 'christoomey/vim-tmux-navigator'  " Vim / `tmux` window navigation
Plug 'RyanMillerC/better-vim-tmux-resizer'  " Vim / `tmux` window resizing
" Searching
Plug 'junegunn/fzf'  " Core `fzf` integration
Plug 'junegunn/fzf.vim'  " Better `fzf` searching
" UI
Plug 'sainnhe/sonokai'  " Color scheme
Plug 'machakann/vim-highlightedyank'  " Highlight yanked text
Plug 'ryanoasis/vim-devicons'  " Nerd Font icons
Plug 'itchyny/lightline.vim'  " Better status and tab lines
Plug 'wellle/context.vim'  " Show current context
" VCS
Plug 'mhinz/vim-signify'  " VCS gutter signs for changed lines
Plug 'tpope/vim-fugitive'  " Git integration
" LSP
Plug 'prabirshrestha/vim-lsp'  " LSP engine
Plug 'mattn/vim-lsp-settings'  " LSP registry and installer
" Completion
Plug 'prabirshrestha/asyncomplete.vim'  " Async completion engine
Plug 'prabirshrestha/asyncomplete-lsp.vim'  " LSP completion source
Plug 'prabirshrestha/asyncomplete-buffer.vim'  " Buffer completion source
Plug 'prabirshrestha/asyncomplete-file.vim'  " File path completion source
" Snippets
Plug 'hrsh7th/vim-vsnip'  " Snippet engine
Plug 'hrsh7th/vim-vsnip-integ'  " Snippet expansion and completion source
Plug 'rafamadriz/friendly-snippets'  " Snippet library
" Formatting
Plug 'google/vim-maktaba'  " Required dependency for `vim-codefmt`
Plug 'google/vim-glaive'  " Flag configuration for `vim-codefmt`
Plug 'google/vim-codefmt'  " Formatter registry and formatting commands
" Plugin overrides
runtime overrides.plug.vim
call plug#end()
call glaive#Install()

" [[ Options ]]

" Make Esc more responsive.
set ttimeoutlen=5

" Enable true colors. Disable if not supported by the terminal.
set termguicolors

" Use colors that look good on a dark background.
set background=dark

" Configure mode cursors: blinking bar in insert / replace and blinking bar
" elsewhere. Must be set after `termguicolors` or `set t_Co=256`.
let &t_SI = "\e[5 q"
let &t_SR = "\e[3 q"
let &t_EI = "\e[1 q"

" Always assume Unix-style files.
set fileformats=unix

" Don't show the mode, it's already in the status line.
set noshowmode

" Show command in the last line of the screen.
set showcmd

" Don't automatically wrap lines.
set nowrap

" Enable line numbers.
set number

" Enable relative line numbers.
set relativenumber

" Enable sign column.
set signcolumn=yes

" Sets how to display split and fold delimiters.
set fillchars=vert:│,fold:·,foldsep:│

" Sets how to display certain whitespace characters in the editor.
set list
set listchars=tab:»\ ,trail:·,nbsp:␣,precedes:◀,extends:▶

" Configure how new splits should be opened.
set splitbelow
set splitright

" Round indents to nearest multiple of `shiftwidth`.
set shiftround

" Keep current indent when starting a new line.
set autoindent

" Keep current indent for wrapped lines.
set breakindent

" Do smart autoindenting when starting a new line.
set smartindent

" Don't auto-close folds when opening a file.
set foldlevelstart=99

" Use indent folds by default.
set foldmethod=indent

" Case-insensitive searching unless `\C` or one or more capital letters in the
" search term.
set ignorecase
set smartcase

" Highlight search matches.
set hlsearch

" Save undo history.
set undofile

" Disable backups.
set nobackup
set nowritebackup

" Enable default completion.
set omnifunc=syntaxcomplete#Complete
set completeopt=menuone,noinsert,noselect

" What to store in a session. Don't save:
" - Unloaded and hidden buffers
" - Global options and variables
" - Session directory
set sessionoptions=
    \blank,curdir,folds,help,tabpages,winsize,winpos,terminal,localoptions

" [[ Autocommands ]]

augroup autosession
  autocmd!
  autocmd User StartifyReady call s:AutoSession()
augroup END

" Show cursor line only in focused window.
augroup config_cursor_line
  autocmd!
  autocmd VimEnter,WinEnter,FocusGained * setlocal cursorline
  autocmd WinLeave,FocusLost * setlocal nocursorline
augroup END

augroup config_sonokai_highlights
  autocmd!
  " The matched pattern is `$COLORSCHEME` instead of `sonokai`.
  autocmd ColorScheme * call s:ConfigSonokaiHighlights()
augroup END

augroup config_netrw_keymaps
  autocmd!
  autocmd filetype netrw call s:ConfigNetrwKeymaps()
augroup END

" Configure buffer and file path completion sources.
augroup asyncomplete_install
  autocmd!
  autocmd User asyncomplete_setup call s:ConfigBufferCompletion()
  autocmd User asyncomplete_setup call s:ConfigFilePathCompletion()
augroup END

" Configure LSP only for languages that have the server registered.
augroup lsp_install
  autocmd!
  autocmd User lsp_buffer_enabled call s:OnLspBufferEnabled()
  autocmd User lsp_float_opened call s:ConfigLspFloatKeymaps()
  autocmd User lsp_float_closed call s:RevertLspFloatKeymaps()
augroup END

" [[ Commands ]]

command! DiffUnsaved let filetype=&ft
    \ | tab split
    \ | let t:is_diff_tab=1
    \ | leftabove vnew | read ++edit # | execute 'normal! 1Gdd'
    \ | execute 'setlocal bt=nofile bh=wipe nobl noswf ro noma ft=' . filetype
    \ | windo :diffthis

command! -nargs=? DiffGit tab split | let t:is_diff_tab=1 | Gvdiffsplit! <args>
command! DiffGitFileHistory Git log --oneline % | nnoremap <buffer> q :close<CR>
command! DiffGitHistory Git log --oneline | nnoremap <buffer> q :close<CR>
command! DiffGitBlame Git blame | nnoremap <buffer> q :close<CR>

" [[ Plugin configs ]]

" Auto-save current session.
let g:startify_session_dir = s:vim_state . '/session'
let g:startify_session_persistence = 1

" Do not change current working directory when opening files.
let g:startify_change_to_dir = 0

" Ensure VCS gutter signs are enabled after restoring the session.
let g:startify_session_savecmds = ['SignifyEnableAll']

" Returns the session file for the current working directory.
function! s:SessionFile()
  return substitute(getcwd(), '[\\/:]', '%%', 'g') . '.vim'
endfunction

" Auto-load session for current working directory if it exists.
function! s:AutoSession()
  let l:session_file = s:SessionFile()
  if filereadable(g:startify_session_dir . '/' . l:session_file)
    execute 'SLoad ' . l:session_file
  endif
endfunction

" Toggle maximization of the current window.
let s:zen_mode = 0
function! s:ToggleZenMode() abort
  if s:zen_mode
    let s:zen_mode = 0
    call feedkeys("\<C-w>=", 'n')
  else
    let s:zen_mode = 1
    call feedkeys("\<C-w>\|\<C-w>_", 'n')
  endif
endfunction

" Highlight yank for 300 ms.
let g:highlightedyank_highlight_duration = 300

" Disable default EasyMotion keymaps.
let g:EasyMotion_do_mapping = 0

" Write all buffers before navigating outside of Vim.
let g:tmux_navigator_save_on_switch = 1

" If Vim is the zoomed pane, wrap around Vim instead of unzooming.
let g:tmux_navigator_disable_when_zoomed = 1

" Resize windows in increments of 5.
let g:tmux_resizer_resize_count = 5
let g:tmux_resizer_vertical_resize_count = 5

let g:fzf_action = {
    \ 'ctrl-t': 'tab split',
    \ 'ctrl-s': 'split',
    \ 'ctrl-v': 'vsplit' }

" Disable `netrw` banner and use long listing style.
let g:netrw_banner = 0
let g:netrw_liststyle = 1

" Disable current context by default and don't add mappings.
let g:context_enabled = 0
let g:context_add_mappings = 0

" Show diagnostics inline and as float on cursor hover.
let g:lsp_diagnostics_virtual_text_align = 'after'
let g:lsp_diagnostics_virtual_text_padding_left = 2
let g:lsp_diagnostics_virtual_text_wrap = 'truncate'
let g:lsp_diagnostics_float_cursor = 1

" Registers buffer completion source.
function! s:ConfigBufferCompletion() abort
  call asyncomplete#register_source(
      \ asyncomplete#sources#buffer#get_source_options({
          \ 'name': 'buffer',
          \ 'allowlist': ['*'],
          \ 'completor': function('asyncomplete#sources#buffer#completor'),
          \ }))
endfunction

" Registers file path completion source.
function! s:ConfigFilePathCompletion() abort
  call asyncomplete#register_source(
      \ asyncomplete#sources#file#get_source_options({
          \ 'name': 'file',
          \ 'allowlist': ['*'],
          \ 'completor': function('asyncomplete#sources#file#completor'),
          \ }))
endfunction

" Enables LSP completion and tags.
function! s:OnLspBufferEnabled() abort
  setlocal omnifunc=lsp#complete
  if exists('+tagfunc')
    setlocal tagfunc=lsp#tagfunc
  endif
endfunction

" Diagnostic icons:
" - Error: `nf-md-close_circle_outline`
" - Warning: `nf-md-alert_outline`
" - Info: `nf-md-information_outline`
" - Hint: `nf-md-lightbulb_outline`
let g:lsp_diagnostics_signs_error = {'text': '󰅚'}
let g:lsp_diagnostics_signs_warning = {'text': '󰀪'}
let g:lsp_diagnostics_signs_information = {'text': '󰋽'}
let g:lsp_document_code_action_signs_hint = {'text': '󰌶'}

" Returns the current session name and icon (`nf-fa-folder`).
function! g:SessionName() abort
  if !filereadable(v:this_session)
    return ''
  endif
  let l:session_path = substitute(v:this_session, '%%', '/', 'g')
  let l:session_name = fnamemodify(l:session_path, ':t:r')
  return !empty(l:session_name) ? ' ' . l:session_name : ''
endfunction

" Returns the current Git branch name and icon (`nf-fa-code_branch`).
function! g:BranchName() abort
  let l:branch = FugitiveHead()
  return !empty(l:branch) ? ' ' . l:branch : ''
endfunction

" Returns the current filetype name and icon.
function! g:FileType() abort
  let l:icon = WebDevIconsGetFileTypeSymbol() . ' '
  return empty(&filetype) ? 'no ft' : l:icon . &filetype
endfunction

" Returns the active LSPs and icon (`nf-fa-cog`).
function! g:LspStatus() abort
  let l:lsps = lsp#get_allowed_servers()
  return !empty(l:lsps) ? ' ' . join(l:lsps) : ''
endfunction

" Lightline separator icons:
" - `nf-pl-left_hard_divider`
" - `nf-pl-right_hard_divider`
" - `nf-pl-left_soft_divider`
" - `nf-pl-right_soft_divider`
let g:lightline = {
    \ 'colorscheme': $COLORSCHEME,
    \ 'active': {
    \   'left': [['mode', 'paste'], ['session', 'branch'], ['filename']],
    \   'right': [['lineinfo'], ['percentwin'], ['lsp_status', 'ft']],
    \ },
    \ 'inactive': {
    \   'left': [['filename']],
    \   'right': [['lineinfo'], ['percentwin'], ['ft']],
    \ },
    \ 'separator': { 'left': "", 'right': "" },
    \ 'subseparator': { 'left': "", 'right': "" },
    \ 'component_function': {
    \   'session': 'g:SessionName',
    \   'branch': 'g:BranchName',
    \   'lsp_status': 'g:LspStatus',
    \   'ft': 'g:FileType',
    \ },
    \ }

" [[ Color scheme ]]

function! s:ConfigSonokaiHighlights() abort
  if g:colors_name != 'sonokai'
    return
  endif

  " Set the highlighted yank to match search.
  highlight! link HighlightedyankRegion IncSearch

  let l:palette = sonokai#get_palette('default', {})

  " Override window separator to match tab and status lines.
  call sonokai#highlight('VertSplit', l:palette.grey_dim, l:palette.bg1)

  " Override `fzf-lua` highlights for better contrast.
  let g:fzf_colors['info'] = ['fg', 'Comment']
  let g:fzf_colors['spinner'] = ['fg', 'Comment']
  let g:fzf_colors['bg+'] = ['bg', 'Pmenu']
endfunction

" If the terminal supports colors, try to set the configured color scheme.
"
" Must be set after the `background` and `syntax`. Must be set after the
" `config_sonokai_highlights` `augroup` and the `s:ConfigSonokaiHighlights`
" function definitions.
if &t_Co >= 256
  colorscheme $COLORSCHEME
endif

" [[ Keymaps ]]

" Set `<leader>` key.
let g:mapleader = "\<space>"
noremap <space> <nop>

" Set macro completion trigger key.
set wildcharm=<C-z>

" Required to map the Alt key.
for key in 'hjkl=S'
  execute "set <M-" . key . ">=\e" . key
endfor

" General:
" - M = [m]anage plugins
" - S = [s]ave buffer
" - Q = [q]uit
" - K = show [k]eyword help
" - <esc> = clear search highlights
" - u = [u]ndo
" - <C-r> = [r]edo
" - <C-c> = [c]opy last yank to system clipboard using OSC52
" - s + a/d/A/S = [s]ort [a]scending / [d]escending (unique)
" - gj / gk = [g]o to previous / next location
" - gf = [g]o to [f]ile under cursor / selected [f]ile
" - gx = [g]o to URI with e[x]ternal system handler
" - g + {1-9} = [g]o to tab
" - <C-u/d> = jump half page [u]p / [d]own
" - { / } = jump to previous / next blank line
" - [m / ]m = jump to previous / next start of Java-style method or class
" - [M / ]M = jump to previous / next end of Java-style method or class
" - f/F/t/T/;/, = find character in line motions
" - <C-f> = multi-window EasyMotion [f]ind
" - [q / ]q / [Q / ]Q = jump to previous / next / first / last [q]uickfix
" - [l / ]l / [L / ]L = jump to previous / next / first / last [l]ocation
" - <leader>w = print [w]inbar info (current buffer path)
map Y y$
nnoremap M :PlugStatus<CR>
nnoremap S :w<CR>
nnoremap Q :quitall<CR>
nnoremap <esc> <C-c>:nohlsearch<CR>
nmap <C-c> :OSCYankRegister<CR>
xnoremap sa :sort u<CR>
xnoremap sd :sort! u<CR>
xnoremap sA :sort<CR>
xnoremap sD :sort!<CR>
nnoremap gj <C-o>
nnoremap gk <C-i>
for i in '123456789'
  execute 'nnoremap g' . i . ' ' . i . 'gt'
endfor
nmap <C-f> <plug>(easymotion-overwin-f)
xmap <C-f> <plug>(easymotion-s)
nnoremap [q :cprev<CR>
nnoremap ]q :cnext<CR>
nnoremap [Q :cfirst<CR>
nnoremap ]Q :clast<CR>
nnoremap [l :lprev<CR>
nnoremap ]l :lnext<CR>
nnoremap [L :lfirst<CR>
nnoremap ]L :llast<CR>
nnoremap <leader>w :echo expand('%')<CR>

" Marks:
" - m + {a-zA-Z} = set [m]ark
" - dm + {a-zA-Z} = [d]elete [m]ark
" - dm + !/* = [d]elete buffer / all [m]arks
" - ' + {a-zA-Z} = go to mark line
" - ` + {a-zA-Z} = go to mark
for m in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  execute 'nnoremap dm' . m . ' :delmarks ' . m . '<CR>'
endfor
nnoremap dm! :delmarks!<CR>
nnoremap dm* :delmarks a-zA-Z<CR>

" Window:
" - <C-s/v/t/z/x/w> = perform window action
" - <C-h/j/k/l> = navigate panes across Vim and `tmux`
" - <M-h/j/k/l/=> = resize panes across Vim and `tmux`
nnoremap <C-s> :split<CR>
nnoremap <C-v> :vsplit<CR>
nnoremap <C-t> :tabedit %<CR>
nnoremap <expr> <C-z> <SID>ToggleZenMode()
nnoremap <C-x> :quit<CR>
nnoremap <C-w> :tabclose<CR>
nnoremap <M-=> <C-w>=

" Terminal:
" - X = open terminal
" - <C-e> = [e]xit terminal mode
nnoremap X :terminal<CR>
tnoremap <C-e> <C-\><C-n>

" Session:
" - dS = [d]elete [s]ession
" - <M-S> = [s]ave session
nnoremap <expr> dS ':SDelete! ' . fnamemodify(v:this_session, ':t') . '<CR>'
nnoremap <expr> <M-S> ':SSave! ' . <SID>SessionFile() . '<CR>'

" Search:
" - s + h/k/f/r/b/c/g/./:/'// = [s]earch with picker
" - <C-j/k> = select next / previous item
" - <C-f> = EasyMotion-like [f]ind
" - <C-u/d> = scroll preview [u]p / [d]own
" - <C-l/p> = toggle [l]ine / [p]review wrapping for long lines
" - <tab> = accept selected / toggled items
" - <S-tab> = toggle selected item
" - <C-o/s/v/t> = open selected item in window
" - <esc> = exit
nnoremap s <nop>
nnoremap sh :Helptags<CR>
nnoremap sk :Maps<CR>
nnoremap sf :Files<CR>
nnoremap sr :History<CR>
nnoremap sb :Buffers<CR>
nnoremap sc :GFiles?<CR>
nnoremap sg :Rg<CR>
nnoremap s. :Files %:h<CR>
nnoremap s: :History:<CR>
nnoremap s' :Marks<CR>
nnoremap s/ :BLines<CR>

" Explorer:
" - <C-o> = [o]pen / refresh file explorer
" - j/k (navigate down / up)
" - gf = [g]o to [f]ile / [f]older
" - gp = [g]o to [p]arent directory
" - gx = [g]o to URI with e[x]ternal system handler
" - gh = toggle [g]o to [h]idden files
" - ad = [a]dd new [d]irectory
" - af = [a]dd new [f]ile
" - cc = [r]ename node
" - dd = [d]elete node
" - <C-e> = [e]xit
" - g? = show help
nnoremap <C-o> :Explore<CR>
function! s:ConfigNetrwKeymaps() abort
  map <buffer> <C-o> <C-l>
  map <buffer> gp -
  map <buffer> gf <CR>
  map <buffer> cc R
  map <buffer> af %
  map <buffer> ad d
  map <buffer> dd D
  map <buffer> gx x
  map <buffer> <C-e> :Rexplore<CR>
  map <buffer> g? <F1>
endfunction

" VCS:
" - [c / ]c / [C / ]C = jump to previous / next / first / last [c]hanged hunk
" - dvu = [d]iff [v]iew [u]nsaved buffer changes
" - dv + o/O/h/H/b = [d]iff [v]iew [o]pen / (file) [h]istory / [b]lame
"   - q = [q]uit diff tab / window
"   - g? = show help
nnoremap dvu :DiffUnsaved<CR>
nnoremap dvo :DiffGit<CR>
nnoremap dvO :DiffGit<space>
nnoremap dvh :DiffGitFileHistory<CR>
nnoremap dvH :DiffGitHistory<CR>
nnoremap dvb :DiffGitBlame<CR>
nnoremap <expr> q exists('t:is_diff_tab') ? ':tabclose<CR>' : 'q'

" Completion:
" - <C-space> = trigger completion
" - <C-j/k> = select next / previous item
" - <C-h/l> = jump to previous / next snippet placeholder
" - <tab> = accept selected item
" - <C-e> = [e]xit
imap <C-@> <plug>(asyncomplete_force_refresh)
imap <C-space> <plug>(asyncomplete_force_refresh)
inoremap <C-j> <C-n>
inoremap <C-k> <C-p>
imap <expr> <C-l> vsnip#available(1) ? '<plug>(vsnip-expand-or-jump)' : ''
smap <expr> <C-l> vsnip#available(1) ? '<plug>(vsnip-expand-or-jump)' : ''
imap <expr> <C-h> vsnip#available(-1) ? '<plug>(vsnip-jump-prev)' : ''
smap <expr> <C-h> vsnip#available(-1) ? '<plug>(vsnip-jump-prev)' : ''
inoremap <expr> <tab> pumvisible() ? '<C-y>' : '<tab>'
cnoremap <C-@> <C-z>
cnoremap <C-space> <C-z>
cnoremap <C-j> <C-n>
cnoremap <C-k> <C-p>
cnoremap <tab> <C-y>

" Code:
" - <leader>= = format
" - <leader>-- = toggle line comment
" - <leader>- = toggle comment
" - <leader>f = toggle [f]old
" - <leader>c = toggle current [c]ontext
" - <leader>q = toggle [q]uickfix window
nnoremap <leader>= :FormatCode<CR>
xnoremap <leader>= :FormatLines<CR>
nmap <leader>-- gcc
nmap <leader>- gc
xmap <leader>- gc
nnoremap <leader>f za
nnoremap <leader>c :ContextToggleWindow<CR>
nnoremap <expr> <leader>q
    \ empty(filter(getwininfo(), 'v:val.quickfix'))
    \ ? ':copen<CR>' : ':cclose<CR>'

" LSP:
" - L = install [L]SP server for current file
" - g + d/D/i/r/t = perform code navigation
" - [r / ]r = jump to previous / next [r]eference
" - [d / ]d / [w / ]w / [e / ]e = jump to previous / next diagnostic by seveirty
" - H = show [h]elp
"   - <C-u/d> = scroll help [u]p / [d]own
"   - <esc> = [e]xit
" - <leader>H = toggle inlay [h]ints
" - <leader>r = [r]ename symbol under cursor
" - <leader>a = code [a]ctions
"   - j/k = select next / previous item
"   - # = accept item #
"   - <CR> = accept selected item
"   - <esc> = [e]xit
nnoremap L :LspInstallServer<CR>
nmap gd <plug>(lsp-definition)
nmap gD <plug>(lsp-declaration)
nmap gi <plug>(lsp-implementation)
nmap gr <plug>(lsp-references)
nmap gt <plug>(lsp-type-hierarchy)
nmap [r <plug>(lsp-previous-reference)
nmap ]r <plug>(lsp-next-reference)
nmap [e <plug>(lsp-previous-error)
nmap ]e <plug>(lsp-next-error
nmap [w <plug>(lsp-previous-warning)
nmap ]w <plug>(lsp-next-warning)
nmap [d <plug>(lsp-previous-diagnostic)
nmap ]d <plug>(lsp-next-diagnostic)
nmap H <plug>(lsp-hover-float)
nmap <leader>r <plug>(lsp-rename)
nmap <leader>a <plug>(lsp-code-action-float)

function! s:ConfigLspFloatKeymaps() abort
  nmap <buffer> <esc> <C-c><plug>(lsp-preview-close)
  nnoremap <buffer> <expr> <C-u> lsp#scroll(-5)
  nnoremap <buffer> <expr> <C-d> lsp#scroll(+5)
endfunction

function! s:RevertLspFloatKeymaps() abort
  silent! nunmap <buffer> <esc>
  silent! nunmap <buffer> <C-u>
  silent! nunmap <buffer> <C-d>
endfunction

" [[ Config overrides ]]

" Load optional user overrides.
runtime overrides.vim
