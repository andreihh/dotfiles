" vimrc: configures Vim.
"
" Requires Vim9+ and `ripgrep`.

" Define XDG directories if unset.
if empty($XDG_CONFIG_HOME)
  let $XDG_CONFIG_HOME = $HOME . "/.config"
endif
if empty($XDG_DATA_HOME)
  let $XDG_DATA_HOME = $HOME . "/.local/share"
endif
if empty($XDG_STATE_HOME)
  let $XDG_STATE_HOME = $HOME . "/.local/state"
endif

" Set XDG-compliant directories.
let vim_home = $XDG_CONFIG_HOME . '/vim'
let vim_data = $XDG_DATA_HOME . '/vim'
let vim_state = $XDG_STATE_HOME . '/vim'

" Configure spell directory.
call mkdir(vim_home . 'spell', 'p')

" Configure state files and directories.
call mkdir(vim_state, 'p')
let &viminfofile = vim_state . '/viminfo'
let &backupdir = vim_state . '//'
let &directory = vim_state . '//'
let &viewdir = vim_state . '//'
let &undodir = vim_state . '//'
let g:netrw_home = vim_state

" Install the `vim-plug` plugin manager. Commands:
" - :PlugInstall
" - :PlugUpdate
" - :PlugClean
if empty(glob(vim_home . '/autoload/plug.vim'))
  silent execute '!curl -fLo "' . vim_home . '/autoload/plug.vim" --create-dirs'
      \ . ' https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" Enable plugins via vim-plug.
call plug#begin(vim_data . '/plugged')
Plug 'editorconfig/editorconfig-vim'  " File encodings, indentation, etc.
Plug 'tpope/vim-sensible'  " Sensible settings.
Plug 'tpope/vim-surround'  " Better surround motions.
Plug 'tpope/vim-commentary'  " Commenting lines.
Plug 'mhinz/vim-signify'  " VCS gutter signs for changed lines.
Plug 'mkitt/tabline.vim'  " Tab numbers in tab line.
Plug 'easymotion/vim-easymotion'  " Better navigation motions.
Plug 'udalov/kotlin-vim'  " Kotlin syntax highlighting.
Plug 'sainnhe/sonokai'  " Sonokai colorscheme.
" Better `tmux` integration.
Plug 'christoomey/vim-tmux-navigator'
Plug 'RyanMillerC/better-vim-tmux-resizer'
" Fuzzy searching.
Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
" Vim LSP plugins.
Plug 'prabirshrestha/vim-lsp'
Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/asyncomplete-lsp.vim'
Plug 'mattn/vim-lsp-settings'
" Code formatting.
Plug 'google/vim-maktaba'
Plug 'google/vim-glaive'
Plug 'google/vim-codefmt'
call plug#end()
call glaive#Install()

" Use the system clipboard.
set clipboard=unnamedplus

" Always assume Unix-style files.
set fileformats=unix

" When wrap is set to off lines will not wrap.
set nowrap

" Show cursor line only in focused pane.
augroup CursorLine
  au!
  au VimEnter * setlocal cursorline
  au WinEnter * setlocal cursorline
  au BufEnter * setlocal cursorline
  au WinLeave * setlocal nocursorline
augroup END

" Print relative line numbers in front of each line.
set relativenumber

" Print the absolute line number in front of the current line.
set number

" Highlight tabs, trailing whitespaces, and overrunning lines.
set list

" When a bracket is inserted, briefly jump to the matching one.
set showmatch

" Show current mode.
set showmode

" Show command in the last line of the screen.
set showcmd

" Set custom status line.
set statusline=[%f]%([%M%R%H%W]%)%q%=[\ %l:%c\ \|\ %p%%\ \|\ %LL\ ]

" When there is a previous search pattern, highlight all its matches.
set hlsearch

" Ignore case in search patterns.
set ignorecase

" When increasing / decreasing indent level, round to nearest multiple of
" shiftwidth.
set shiftround

" Copy indent from current line when starting a new line.
set autoindent

" Do smart autoindenting when starting a new line.
set smartindent

" Open new split panes to right and bottom, which feels more natural.
set splitbelow
set splitright

" Enable sign column.
set signcolumn=yes

" Don't automatically close folds when opening a file.
set foldlevelstart=99

" Use indent folds by default.
set foldmethod=indent

" When set to "dark", Vim wil try to use colors that look good on a dark
" background.
set background=dark

" If the terminal supports colors, try to enable true colors. Disable with
" `set notermguicolors` if the colors don't render properly.
if &t_Co >= 256 && has('termguicolors')
  set termguicolors
endif

function! s:try_set_colorscheme()
  " Optionally enable a color scheme if the terminal supports colors. The color
  " scheme must be set after setting the background and enabling syntax.
  if &t_Co >= 256
    try
      colorscheme $COLORSCHEME
      if $COLORSCHEME == "sonokai"
        let l:palette = sonokai#get_palette("default", {})

        " Override window separator to match tab and status lines.
        call sonokai#highlight("VertSplit", l:palette.grey_dim, l:palette.bg1)

        " Override visual highlight to higher contrast.
        call sonokai#highlight("Visual", l:palette.none, l:palette.bg4)
        call sonokai#highlight(
            \ "VisualNOS",
            \ l:palette.none,
            \ l:palette.bg4,
            \ "underline")
      endif
    catch
      echo "Colorscheme " . $COLORSCHEME . " not found!"
    endtry
  endif
endfunction

augroup ColorScheme
  au!
  autocmd VimEnter * call s:try_set_colorscheme()
augroup END

" Make Esc more responsive.
set timeout ttimeoutlen=50

" Copy until the end of the line. Consistent with D and C.
nnoremap Y y$

" Cancels search highlighting in normal mode.
nnoremap <esc> :nohlsearch<CR>

" Save buffer.
nnoremap S :w<CR>

" Set <leader> key. Must not have surrounding spaces.
noremap <space> <nop>
let mapleader=" "

" Writes all buffers before navigating outside of Vim.
let g:tmux_navigator_save_on_switch=1

" If Vim is the zoomed pane, wraps around Vim instead of unzooming.
let g:tmux_navigator_disable_when_zoomed=1

" Panes should be resized in increments of 5.
let g:tmux_resizer_resize_count=5
let g:tmux_resizer_vertical_resize_count=5

" Required to map the Alt key.
for key in "hjkl="
  execute "set <M-" . key . ">=\e" . key
endfor

" Control and navigate panes:
" - Ctrl-t (new tab)
" - Ctrl-s/v (split pane horizontally / vertically)
" - Ctrl-h/j/k/l (navigate panes)
" - Alt-h/j/k/l (resize panes)
" - Alt-= (resize all panes equally)
" - Ctrl-z (close all panes except current one)
" - Ctrl-x (close pane)
" - Ctrl-w (close tab)
" - Q (quit)
nnoremap <C-t> :tabedit %<CR>
nnoremap <C-s> :split<CR>
nnoremap <C-v> :vsplit<CR>
nnoremap <M-=> <C-w>=
nnoremap <C-z> :only<CR>
nnoremap <C-x> :quit<CR>
nnoremap <C-w> :tabclose<CR>
nnoremap Q :quitall<CR>

" File explorer should use long listing style and disable the netrw banner.
let g:netrw_banner = 0
let g:netrw_liststyle = 1

" File explorer actions:
" - <C-o> (open / refresh file explorer)
" - j/k (navigate down / up)
" - gf (activate node)
" - gp (change root to parent directory)
" - ad (create new directory)
" - af (create new file)
" - cc (rename node)
" - dd (delete node)
" - gx (open with external handler)
" - gh (toggle go to hidden files)
" - <esc> (exit file explorer)
nnoremap <C-o> :Explore<CR>
au filetype netrw map <buffer> <C-o> <C-l>
au filetype netrw map <buffer> gp -
au filetype netrw map <buffer> gf <CR>
au filetype netrw map <buffer> cc R
au filetype netrw map <buffer> af %
au filetype netrw map <buffer> ad d
au filetype netrw map <buffer> dd D
au filetype netrw map <buffer> gx x
au filetype netrw map <buffer> <esc> :Rexplore<CR>

" Navigation actions:
" - g1 /g2 / ... / g9 (go to tab)
" - gj / gk (go to previous / next location)
" - gf (go to file under cursor or to selected file)
" - gx (open URI under cursor or selected URI)
" - [c / ]c / [C / ]C (go to previous / next / first / last changed hunk)
" - [m / ]m (go to previous / next start of Java-style method or class)
" - [M / ]M (go to previous / next end of Java-style method or class)
" - { / } (go to previous / next blank line)
" - Ctrl-u/d (go half page up / down)
nnoremap g1 1gt
nnoremap g2 2gt
nnoremap g3 3gt
nnoremap g4 4gt
nnoremap g5 5gt
nnoremap g6 6gt
nnoremap g7 7gt
nnoremap g8 8gt
nnoremap g9 9gt
nnoremap gj <C-o>
nnoremap gk <C-i>

" Folding:
" - <leader>f (toggle fold)
nnoremap <leader>f za

" Code commenting:
" - <leader>- (comment line or selected range)
noremap <leader>- :Commentary<CR>

" Autocomplete shortcuts:
" - Ctrl-Space (trigger autocomplete)
" - Ctrl-j/k (cycle items)
" - Tab (accept item)
" - Ctrl-e (cancel)
imap <C-@> <C-space>
imap <C-space> <C-x><C-o>
inoremap <C-j> <C-n>
inoremap <C-k> <C-p>
inoremap <expr> <tab> pumvisible() ? "\<C-y>" : "\<tab>"

" Enable default autocompletion.
set omnifunc=syntaxcomplete#Complete

" Fuzzy searching:
" - sh (search help)
" - sk (search keymaps)
" - sf (search files)
" - sc (search uncommitted Git files)
" - sb (search open buffers)
" - s/ (search inside current buffer)
" - Ctrl-j/k (cycle items)
" - Ctrl-o (open item in current buffer)
" - Ctrl-t (open item in new tab)
" - Ctrl-s/v (open item in horizontal / vertical split)
" - Ctrl-e (cancel)
nnoremap s <nop>
nnoremap sh :Helptags<CR>
nnoremap sk :Maps<CR>
nnoremap sf :Files<CR>
nnoremap sc :GFiles?<CR>
nnoremap sg :Rg<CR>
nnoremap sb :Buffers<CR>
nnoremap s/ :BLines<CR>
let g:fzf_action = {
    \ 'ctrl-t': 'tab split',
    \ 'ctrl-s': 'split',
    \ 'ctrl-v': 'vsplit' }

" Code navigation:
" - gd (go to definition)
" - gD (go to declaration)
" - gi (go to implementation)
" - gr (go to references)
" - [r / ]r (go to previous / next reference)
" - [e / ]e (go to previous / next error)
" - [w / ]w (go to previous / next warning)
" - [d / ]d (go to previous / next diagnostic)
" - <leader><leader> + motion (trigger EasyMotion)
nmap gd <plug>(lsp-definition)
nmap gD <plug>(lsp-declaration)
nmap gi <plug>(lsp-implementation)
nmap gr <plug>(lsp-references)
nmap [r <plug>(lsp-previous-reference)
nmap ]r <plug>(lsp-next-reference)
nmap [e <plug>(lsp-previous-error)
nmap ]e <plug>(lsp-next-error
nmap [w <plug>(lsp-previous-warning)
nmap ]w <plug>(lsp-next-warning)
nmap [d <plug>(lsp-previous-diagnostic)
nmap ]d <plug>(lsp-next-diagnostic)

" Show diagnostics inline and as float on cursor hover.
let g:lsp_diagnostics_virtual_text_align = 'after'
let g:lsp_diagnostics_virtual_text_padding_left = 2
let g:lsp_diagnostics_virtual_text_wrap = 'truncate'
let g:lsp_diagnostics_float_cursor = 1

" Code inspection and transformation:
" - <leader>h (show help)
" - <leader>t (type hierarchy)
" - <leader>r (rename)
" - <leader>c (comment line or selected range)
" - <leader>= (format file or selected range)
" - <leader>q (toggle quickfix pane)
" - Ctrl-f/b (scroll float forward / backward)
" - Ctrl-c (close float)
nmap <leader>h <plug>(lsp-hover-float)
nmap <leader>t <plug>(lsp-type-hierarchy)
nmap <leader>r <plug>(lsp-rename)
nnoremap <leader>= :FormatCode<CR>
vnoremap <leader>= :FormatLines<CR>
nnoremap <expr> <leader>q
    \ empty(filter(getwininfo(), 'v:val.quickfix'))
    \ ? ":copen\<CR>" : ":cclose\<CR>"
nmap <expr> <C-f> lsp#scroll(-5)
nmap <expr> <C-b> lsp#scroll(+5)

" Code actions shortcuts:
" - <leader>a (trigger code actions)
" - # (accept numbered item)
" - j/k (cycle items)
" - Enter (accept selected item)
" - Esc (cancel)
nmap <leader>a <plug>(lsp-code-action-float)

function! s:on_lsp_buffer_enabled() abort
  " Enable LSP autocompletion.
  setlocal omnifunc=lsp#complete
  if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif

  " Override autocomplete action.
  imap <buffer> <C-space> <plug>(asyncomplete_force_refresh)
endfunction

augroup lsp_install
  au!
  " Call s:on_lsp_buffer_enabled only for languages that have the server
  " registered.
  autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END
